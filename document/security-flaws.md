# Cyber Security Project I (OWASP list 2017)

## Installation
The project application utilises Python’s Django framework. Because this project is part of the course Cyber Security, it is assumed that user has Python and Django installed. In addition, user must install Django Axes to ensure the correct functionality of the project application. Django Axes can be installed with command 
```
pip install django-axes[ipware]
```
(see more about Django Axes: https://github.com/jazzband/django-axes). 

## Security flaws and fixes

### Flaw 1: A1 Injection
The SQL injection is a common example of injection vulnerability. In SQL injection, malicious SQL code is utilized to manipulate the backend database, allowing unauthorised access to data that was not intended for viewing or alteration. Attackers aiming to execute SQL injection tampers a regular SQL query to exploit inadequately sanitized input vulnerabilities within the database.  

The project application’s function [send_message()](https://github.com/Na-na13/cyber-security-project-i/blob/8de972f38bd5bae1b2af121e4b86bcc16669f3fa/project/src/views.py#L122) is vulnerable to SQL-injection. The vulnerable version of the function utilises raw SQL and unsanitised data. The user provided data, namely the sent message, is directly concatenated to the query without parametrisation. The attacker can e.g. give admin privileges to themselves or drop data tables, which leads the application to fail. Utilising Django’s default object-relational mapping layer (ORM) is more secure choice than raw SQL. Django ORM is based on querysets that are protected against SQL-injection by query parameterisation.  

In some cases, raw SQL provides more powerful queries than Django ORM. If utilising raw SQL is justifiable, it is important to sanitise the user provided data and parametrise the queries. Also, it might be relevant to prevent multiple query execution at once (the vulnerable version of send_message() function utilises [executescript()](https://github.com/Na-na13/cyber-security-project-i/blob/8de972f38bd5bae1b2af121e4b86bcc16669f3fa/project/src/views.py#L140), which allows to execute multiple queries at once, instead of execute(), which allows only one query execution at a time).  
(Source: https://docs.djangoproject.com/en/4.2/topics/db/sql/#executing-custom-sql-directly)

### Flaw 2: A2 Broken Authentication
Broken authentication often arises due to improperly implemented authentication and session management functions. Authentication refers to the process of verifying the identity of users, typically through usernames and passwords, while session management involves maintaining and controlling the user's session after authentication.  

Security risks arise when applications lack safeguards against automated attacks like credential stuffing and brute force attempts. In these attack methods, the attackers exploit lists of compromised user credentials. to gain unauthorized access. These methods are based on the assumption of users recycling usernames and passwords across various services. Permitting default, weak, or well-known passwords creates an open door for attackers to breach user accounts.  Despite the well-known risks, relying on weak passwords and using the same password for multiple accounts continue to be a common security oversight. Implementing restrictions against these poor practices within the application reduces the risk of unauthorized access to accounts.  

Session management constitutes the fundamental cornerstone of robust authentication and access controls. Sessions are established upon successful login, assigning users session-specific IDs. Implementing proper session management involves e.g. invalidating session-specific IDs after logout, idle, and absolute timeouts to prevent unauthorised access. Inadequately configured session timeouts, combined with users failing to log out, extends the risk of prolonged authentication, exposing potential security vulnerabilities – especially when using public computers.  

In the project application, credential stuffing attacks are prevented with help of Django Axes, a plugin for keeping track of suspicious login attempts. With Axes, the number of unsuccessful login attempts is limited to 3, after which the associated account is locked for 3 minutes (these numbers are for test reasons, [both are configurable](https://github.com/Na-na13/cyber-security-project-i/blob/1abadf057979012224c3889cb481172fe4ce0bb3/project/project/settings.py#L143)). Axes compares username + IP-address combination to prevent denial of service (DoS) attacks. Comparing only username increases possibility of DoS attack when attackers can try to get access on multiple accounts from same IP-address and get them locked. After every successful login attempt, the login attempt calculator is reset to zero. Axes also logs all login related failures to the database automatically.  
(Source: https://github.com/jazzband/django-axes)  

Weak password check is implemented in the project application with Django’s pluggable configurable [password validators](https://github.com/Na-na13/cyber-security-project-i/blob/1abadf057979012224c3889cb481172fe4ce0bb3/project/project/settings.py#L98). The project application utilizes a default set of validators: UserAttributeSimilarityValidator, MinimumLenghtValidator, CommonPasswordValidator and NumericPasswordValidator (the functionality of each validator is shortly explained within the code). While these default validators constitute the foundational defence against weak passwords, they do not ensure the creation of truly strong passwords.  
(Source: https://docs.djangoproject.com/en/4.2/topics/auth/passwords/#module-django.contrib.auth.password_validation)  

The project application logs the user automatically out after 3 minutes idle time (this is for test reasons, [configurable](https://github.com/Na-na13/cyber-security-project-i/blob/1abadf057979012224c3889cb481172fe4ce0bb3/project/project/settings.py#L139)). Idle time check is done by comparing the timestamp of the last sent HTTP-request with session cookie age. If the timestamp exceeds the cookie age, user is logged out and redirected to the error page. This prevents unauthorised access to user account in cases where users forget to manually log out.  
(Source: https://docs.djangoproject.com/en/4.2/topics/http/sessions/)

### Flaw 3: A5 Broken Access Control
Access control ensures that users are confined within their designated permissions, preventing unauthorized actions. Broken access control allows attackers to evade or circumvent the normal security controls checks. Inadequate access control implementation enables e.g. force browsing to authenticated pages as an unauthenticated user, or gaining access to privileged pages as a standard user. Additionally, attackers can exploit vulnerabilities by directly manipulating the URL, and thus bypassing the application's access controls.  

Django provides several different kinds of access control mechanisms in form of decorators. Within the project application, certain pages restricted to logged in users utilizes [@login required](https://github.com/Na-na13/cyber-security-project-i/blob/1abadf057979012224c3889cb481172fe4ce0bb3/project/src/views.py#L21) -decorator to prevent unauthorized access. Privileged pages, namely the admin pages, are protected with custom [@admin_check](https://github.com/Na-na13/cyber-security-project-i/blob/1abadf057979012224c3889cb481172fe4ce0bb3/project/src/views.py#L37) -decorator. This decorator verifies the user's admin status: in case of not having the admin status, the user is redirected to login page. Without these decorators, attackers can bypass application login entirely and a standard logged-in user can get access to admin pages solely by correctly modifying the URL.  
(Source: https://docs.djangoproject.com/en/4.2/topics/auth/default/#the-login-required-decorator, https://docs.djangoproject.com/en/4.2/topics/auth/default/#limiting-access-to-logged-in-users-that-pass-a-test)  

However, in the project application, broken access control introduces a flaw where user can navigate back to previously visited page, which requires login, even after successful logging out. This vulnerability is patched by controlling the page caching with [@cache_control](https://github.com/Na-na13/cyber-security-project-i/blob/1abadf057979012224c3889cb481172fe4ce0bb3/project/src/views.py#L20) -decorator. This may not be the optimal solution, as the URLs of the previous pages remain visible to the user even though they cannot access the corresponding content.

### Flaw 4:  A7 Cross-site script
Cross-Site Scripting (XSS) attacks constitute a form of injection, in which malicious scripts are injected into websites that are otherwise considered benign and trustworthy. XSS attacks arise when an attacker uses a web application to send malicious code, generally in the form of a browser side script, to a different end user. Three primary categories of XSS attacks exist: reflected XSS, where the malicious script comes from the current HTTP request; stored XSS, wherein the malicious script emerges from the database of the website; and DOM-based XSS, in which the vulnerability resides in client-side code as opposed to server-side code.  

The project application has vulnerability for XSS attack in the function [send_message()](https://github.com/Na-na13/cyber-security-project-i/blob/1abadf057979012224c3889cb481172fe4ce0bb3/project/src/views.py#L122). The user provided data is not properly sanitized before being inserted to the database. Adding to the issue, the front end uses the Django safe filter, which renders HTML content as-is, bypassing the usual escaping process of specific characters, like < and >. This allows the attacker to send messages to every user, containing malicious scripts within.  

Escaping HTML characters is a default setting in Django. However, if this safeguard is disabled, such as by using the mentioned safe filter, the data sanitation can be accomplished other ways. In the project application, data sanitation is achieved using Python built-in [html module]() which converts characters &, < and > to HTML-safe sequences. This data sanitation approach renders the messages exactly as users entered them thus preventing the potential injection of malicious scripts.  
(Source: https://docs.python.org/3/library/html.html)

### Flaw 5: Cross-Site Request Forgery (CSRF) (not on the OWASP 2017 list)
Cross-site request forgery (CSRF) attack is maliciously used to send requests from an authenticated user to a web application. This type of attack occurs when a malicious website contains a link, form button, or some JavaScript that is intended to execute action on the website, using the credentials of a logged-in user who visits the malicious site with their browser. The victim remains unaware of the manipulated requests' outcome, making this attack method especially tricky and capable of causing disruption the scenes. Unlike data theft, CSRF attacks focus on altering the application's state. Despite its exclusion from the OWASP 2017 Top 10 list, CSRF attacks still presents a potential security risk that should not be ignored.  

In Django, the CSRF middleware and template tag provides easy-to-use protection against CSRF attacks. The CSRF middleware is activated by default. This middleware sends a CSRF cookie with the response. The template tag ‘csrf_token’ should be used in any template that uses a POST form if the form is for internal URL. For external URL’s this is not recommended due to the possible leak of the CSRF token.  

In the project application, the send message function is vulnerable to CSRF attacks, because in the corresponding template, the form that uses POST, does not use the CSRF token. By adding the hidden CSRF token field to the form, the CSRF attacks can be avoided.  
(Source: https://docs.djangoproject.com/en/4.2/ref/csrf/)

